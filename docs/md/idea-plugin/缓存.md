# 缓存

### 缓存过期

调大过期时间能提高缓存命中率，提高性能。

调小过期时间能减少Redis的消耗。



懒惰删除：使用的时候发现过期了删除

定期删除：每隔一段时间，选出一部分过期的key删除

立刻删除：开销太大，每个key一个定时器，如果修改过期时间重置计时器



### 缓存淘汰策略

解决的问题：内存不足，要加入新的键值对，旧的也没有过期，淘汰谁。



常见算法：

* LRU 淘汰最近一段时间最长未使用的key
* LFU 淘汰使用次数最低的

Redis支持在设置了过期时间的键值对或所有key中执行LRU、LFU和随机淘汰。实际业务中可以自定义策略，比如优先淘汰非VIP用户的缓存，优先淘汰大对象或好计算的对象、低热度对象。

> 出现的问题：推理网关做图像推理时，调用GPU的代价毕竟高，为了降低后端压力和提升响应速度，因为有些请求是重复的，我们会缓存推理结果。但图片推理过程的结果数据很大，redis资源有限，默认的LRU淘汰策略不太适用。
>
> 我们需要根据客户的等级以及数据的大小自定义缓存淘汰策略。
>
> 使用redis的ZSET实现一个能按照优先级淘汰键值对的机制。ZSET的数据优先级分数的计算规则是用户等级分加数据大小乘系数。
>
> 写入key时使用lua脚本，先判断zset的大小是否超过最大缓存量，超过了就弹出优先级最低的key并删除键值对。没超过就将新key和优先级插入zset，同时写入键值对。
>
> 注意的是，需要监听redis的del事件，当缓存过期被自动删除火手动删除时，要通过订阅者将zset中的key也删除，保证数据一致性。
>
> 另外：缓存大对象的时候，底层数据先返回给业务，异步缓存redis

### 缓存一致性

缓存模式：

* Cache Aside 最基础，一般先写数据库再写缓存，因为业务以数据库为准而缓存会过期

* Read Through 读的时候缓存未命中，缓存代替业务去数据库加载数据

* Write Through 写的时候只写缓存，缓存会去更新数据库

* Write Back 写的时候写缓存，key过期的时候才更新到数据库

* Singleflight 很多线程访问一个key的时候，只有一个线程真的加载数据

* 删除缓存->延迟双删 写数据库的时候，间隔两次删除缓存，防止其他回源操作把旧数据更新到缓存

> 瓜分赛的缓存：核心模式是Cacha Aside，e读时先读缓存，未命中回源数据库，异步写回缓存。写的时候更新数据库，延迟双删缓存，缩小不一致的窗口期。 
>
> 编排引擎，上下文数据中包含了下游可能使用的数据，也算一种缓存。
>
> 促活平台，营销活动预热，防止缓存击穿。

### 缓存穿透、击穿和雪崩

穿透：数据库和缓存都没有，一般是攻击者伪造大量请求，请求不存的数据。

击穿：缓存没有，一般是并发请求热点数据。

雪崩：大量数据同时刻过期，一般是批处理加载时用了同一个过期时间



穿透解决：回写特殊值，标记数据不存在，下一次查询发现特殊值就不再请求数据库/布隆过滤器，假阳性问题概率很低问题不大。

击穿解决：Singleflight模式

雪崩解决：数据批量加载时，给过期时间加上随机值，偏移量要和过期时间成正比，过低过高都不行

（其他思路：限流，单一针对数据库限流）

