# Mysql

### 索引

B+树用于数据库索引的优势

1. B+树的高度比较低，查询性能好
2. B+树的叶子节点串联，方便范围查询
3. B+树的叶子节点存储实际数据，非叶子节点只存储索引关键字，适合放入内存中

​	平衡二叉树或红黑树高度高性能差

​	跳表极端情况会变成链表，平衡性差

​	B树的非叶子节点也存了数据，叶子节点也没串联不方便范围查询



索引坏处

1.增删改不仅要维护数据，还要维护索引，有额外消耗

2.索引会加载到内存消耗内存

3.索引要存储消耗硬盘空间



分类

* 聚簇索引和非聚簇索引

聚簇索引的B+树叶子节点存储实际数据，非聚簇索引的叶子节点只存放了主键，需要回表。

* 覆盖索引

  某次查询的数据全部包含在索引里面，不用回表。



不使用索引的情况

1. 使用了不等于，非前缀查询的LIKE

2. 字段区分很小
3. 使用数学运算或函数
4. 数据量太小



### SQL优化

EXPLAIN命令+sql语句

返回的执行计划：

1.查询到数据的方式，是全表扫描还是索引扫描。

2.候选的索引和用到的索引

3.扫描的行数



加索引的情况：

1.频繁出现在WHERE、ORDER　BY的列，避免全表扫描和内存中再次排序

２.组合索引中区分度很高的列放在左边。



优化的案例：

1.对于非常高频的SQL要避免回表，设置覆盖索引。

2.order by排序的字段加索引。eg 查询用户数据，每个用户多条数据按照更新时间排序

3.分页查询查某一页用limit，偏移不能太大。拿到上一批数据的最大id，加一个where查询条件，偏移量一直是0会非常稳定。

4.大表计数用redis的计数器



### 锁

锁释放的时机：不是语句执行完，而是事务提交或回滚时。



分类：

MySQL锁机制非常丰富，锁和引擎、隔离级别、索引有关系。(隔离级别也和锁有关系，比如说间隙锁和临键锁只有在可重复读的隔离级别下才有效果。)

从范围看分为表锁和行锁。MySQL的InnoDB引擎时借助索引来实现行锁的，如果没用到索引就会锁整张表。

从排他性看分为共享锁和互斥锁。

记录锁锁住某条记录（只针对主键和唯一索引），间隙锁锁住两条记录的间隙，临键锁是记录锁和间隙锁的组合。

表级锁有一个意向锁，用于快速判断一张表是否有行被加锁，避免全表扫描是否有锁。



乐观锁：修改数据的时候再检测是否已经被修改过了（适用于读多写少）

悲观锁：初始时直接加锁保护资源（适用于写多读少）

> 金币瓜分赛使用乐观锁机制去判断用户是否已经瓜分金币。



### MVCC

解决的问题：避免读写阻塞，因为修改某条数据导致其他线程不能读数据是不能接受的。



Mysql的隔离级别

* 读未提交 能查到其他事务未提交的修改，会出现脏读
* 读已提交 能查到其他事务已提交的修改，会出现不可重复读
* 可重复读 一个事务内部读同一个数据结果一样(理论会出现幻读，但临键锁解决了这个问题)。

* 串行化



InnoDB给每个数据行加了两个字段，事务ID，和回滚指针。事务ID标记这行数据是哪个事务改的，回滚指针把这一行所有的历史版本都串联起来，叫版本链。

事务之间的可见性是靠Read View来判断的，它会记录活跃Id列表(已经开始但还没结束的事务)读已提交每次查询的时候会创建新的Read view，可重复读只在事务开始的时候创建。



### 事务

undo log是回滚日志，记录事务修改数据的过程，事务回滚时根据undo log撤销更改

* 插入的数据删除
* 删除的数据没有真的删除只是标记了，删除标记回复成false就行
* 更新数据不涉及主键就变回去，如果更新了主键可以看作先删除原本的行再插入新行



redo log解决的问题：InnoDB引擎读写操作的是缓存池，而不是磁盘，后续缓存池的内容才会刷新到磁盘。redo log解决还没刷新到磁盘数据库就崩溃的问题。

InnoDB在更新缓存池的同时，写一份redo log，万一缓存池的数据没刷新进去，就用redo log来恢复。虽然redo log也要写磁盘，但是是顺序写，比随机写好多了。



binlog是操作日志文件，一个是用于数据库故障恢复，一个用于主从同步（canal中间件也是把自己伪装成从节点）



数据库的读未提交和读已提交其实不满足隔离性，可重复读按理也不满足，但是InnoDB引擎解决了幻读问题，所以Mysql的可重复读和串行化才是满足了ACID。



bin log和redo log的协同二阶段提交

* bin log是逻辑日志，记录数据库操作指令，redo log是物理日志，记录数据页的修改

* bin log一般用于恢复到某个时间，redo log用于故障时将没有从缓存池写入磁盘的数据写入

* 两阶段提交，是为了保证bin log和redo log的数据一致性。给redo log一个prepare状态，然后写入binlog 。

  如果先写bin log，那么从库会有最新数据，而主库因为redo log丢失没有，会主从不一致。先写redo log同理。

  恢复数据时，扫描redo log中prepare的记录，如果binlog中存在且完整，那么这个redo log记录就可以变成commit，否则会回滚。



### 分库分表

主键生成的要求：全局唯一的同时保持自增，支持高并发



常见的算法：

1. UUID

   缺点是UUID生成的ID不是递增的，而我们倾向于数据库使用自增主键，这样插入性能最好。如果随机的话，插入会导致页分裂，严重的时候会发生连锁反应分裂到Ｂ+树的根节点。

   主键相近的记录，在磁盘上位置相近。这样在范围查询的时候，能更充分的利用磁盘的顺序读特性。

　2. 数据库自增

​	不同表主键增长的步长一样，但起始值不同。

3. 雪花算法

   雪花算法采用64位ID，1位保留，41位表示时间戳，10位表示机器ID，12位为序列号。但这只是一种思想，可以自由切割不同比特位，赋予不同的含义。

​	并发度特别高的时候，序列号不够用，可以把时间戳分给序列号用。

> 订单用用户ID进行分库分表，但有时候订单详情要用订单ID去查怎么办？
>
> 主键ID内嵌分库分表键，借鉴雪花算法，机器码改成用户ID的后几位，这样取出主键的用户ID位，就能知道去哪个分表中去查数据。