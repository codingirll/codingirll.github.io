# Redis

### 单线程

单线程是指处理命令的时候单线程，持久化、数据同步等是由其他线程完成的。

Redis的高性能源自，一方面是处理命令时是纯内存操作，二是6.0以后采用了epoll和Reactor结合的IO模型，非常高效。



epoll会管理套接字，实现增删改查。底层数据结构是一个监控套接字的红黑树和一个叫就绪列表的双向链表。为了维护epoll的数据结构，有三个系统调用：

* epoll_creat是创建epoll结构
* epoll_ctl是增删改套接字
* epoll_wait是根据要求返回符合条件的套接字

只要套接字符合条件，就会被移动到就绪列表，不一定要epoll_wait调用。调用时可以用-1、0、毫秒数去控制超时时间。

epoll通过中断判断数据来或者超时。当数据发送到网卡时，网卡驱动告诉epoll有数据，发生时钟中断时，内核会检查调用epoll_wait的线程有没有超时，超时会唤醒线程，就会得到超时响应。



Reactor模式可以看成是一个分发器加一些处理器。Reactor模式发起epoll系统调用，如果是读写描述符就交给Hander处理，如果是连接描述符就交给Acceptor处理，监听这个连接的读写事件。当然Redis是单线程模型，所以他们其实是一个线程。



优点：

不会引入上下文切换的开销，不需要锁保护共享资源

Redis是内存数据库，瓶颈只出现在网络IO和内存大小上，多线程的提升不大。



### 分布式锁

Redis分布式锁的实现：锁其实只是一个普通的键值对，

加锁调用SETNX，排他性的设置键值对，设置成功说明加锁成功，设置失败说明要等待其他人释放锁

释放锁调用DEL删除键值对。



Redlock算法是为了解决redis锁被别人拿到的情况(加锁写入主库，主库崩溃从库变主库没加锁，别人拿到锁)。加锁的时候要在多个redis节点同时加锁，大多数节点加锁成功才叫成功。



> 控制台后端只能有一个实例去推送用户计量计费的数据。
>
> 加锁要设置过期时间，防止实例崩溃锁无法释放导致死锁。
>
> 设计全局唯一的锁id，解锁要安全解锁，避免因为redis故障释放其他实例的锁。
>
> 引入续约机制，一般推送10s就完成了，但为了应对极端情况，万一这次推送时间特别长，开启一个线程，隔10s判断锁是否持有，如果持有就重置过期时间，保证长任务完成。

